package com.clarita.governance.annotations;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Excludes an element from governance scanning.
 *
 * <p>Use this annotation sparingly to exclude code that legitimately does not
 * need test coverage validation. All exclusions are tracked and reported.</p>
 *
 * <h2>Valid Use Cases</h2>
 * <ul>
 *   <li>Generated code (e.g., Lombok, MapStruct)</li>
 *   <li>Configuration classes with no business logic</li>
 *   <li>Legacy code scheduled for removal</li>
 *   <li>Third-party integration code tested elsewhere</li>
 *   <li>Trivial getters/setters with no logic</li>
 * </ul>
 *
 * <h2>Invalid Use Cases (code review should reject)</h2>
 * <ul>
 *   <li>Avoiding testing because it's "too hard"</li>
 *   <li>Time pressure to skip tests</li>
 *   <li>Core business logic</li>
 * </ul>
 *
 * <h2>Usage Examples</h2>
 *
 * <h3>Temporary exclusion with expiration:</h3>
 * <pre>{@code
 * @GovernanceIgnore(
 *     reason = "Legacy code scheduled for removal in Q2 2024",
 *     until = "2024-06-30",
 *     approvedBy = "tech-lead"
 * )
 * public void legacyMethod() {
 *     // Legacy implementation
 * }
 * }</pre>
 *
 * <h3>Permanent exclusion for generated code:</h3>
 * <pre>{@code
 * @GovernanceIgnore(
 *     reason = "Generated by Lombok - no business logic",
 *     category = IgnoreCategory.GENERATED_CODE
 * )
 * @Data
 * public class ProviderDTO {
 *     // Fields only
 * }
 * }</pre>
 *
 * <h2>Audit Tracking</h2>
 * <p>All ignored elements are tracked in governance reports for audit purposes.
 * Expired ignores (past the {@link #until()} date) generate warnings.</p>
 *
 * @since 1.0.0
 */
@Target({ElementType.METHOD, ElementType.TYPE, ElementType.PACKAGE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface GovernanceIgnore {

    /**
     * Reason for exclusion (required).
     *
     * <p>Must clearly explain why this code doesn't need test coverage validation.</p>
     *
     * @return exclusion reason
     */
    String reason();

    /**
     * Expiration date for this exclusion (ISO format: YYYY-MM-DD).
     *
     * <p>After this date, the exclusion generates a warning.</p>
     * <p>Leave empty for permanent exclusions (use sparingly).</p>
     *
     * @return expiration date
     */
    String until() default "";

    /**
     * Who approved this exclusion.
     *
     * <p>Should be a tech lead, architect, or compliance officer.</p>
     *
     * @return approver identifier
     */
    String approvedBy() default "";

    /**
     * Category of exclusion for reporting purposes.
     *
     * @return ignore category
     */
    IgnoreCategory category() default IgnoreCategory.OTHER;

    /**
     * Ticket reference for tracking (e.g., Jira ticket).
     *
     * @return ticket reference
     */
    String ticketRef() default "";

    /**
     * Categories for governance ignore reasons.
     */
    enum IgnoreCategory {
        /**
         * Code generated by tools (Lombok, MapStruct, etc.)
         */
        GENERATED_CODE("Generated code with no business logic"),

        /**
         * Configuration classes
         */
        CONFIGURATION("Configuration classes without business logic"),

        /**
         * Legacy code scheduled for removal
         */
        LEGACY("Legacy code scheduled for removal"),

        /**
         * Third-party integration tested elsewhere
         */
        THIRD_PARTY("Third-party integration tested elsewhere"),

        /**
         * Trivial code (getters, setters, toString)
         */
        TRIVIAL("Trivial code without complex logic"),

        /**
         * Test utilities and helpers
         */
        TEST_UTILITY("Test utility classes"),

        /**
         * Infrastructure/plumbing code
         */
        INFRASTRUCTURE("Infrastructure code without business logic"),

        /**
         * Other reason (must be documented)
         */
        OTHER("Other reason - see documentation");

        private final String description;

        IgnoreCategory(String description) {
            this.description = description;
        }

        public String getDescription() {
            return description;
        }
    }
}
